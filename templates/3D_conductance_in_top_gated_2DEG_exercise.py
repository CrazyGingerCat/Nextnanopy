#***************************************************************************!
# (c) nextnano GmbH                                                         !
#                                                                           !
# This is an input file for the following tutorial:                         !
#   - top-gated 2D electron gases structure                                 !
#                                                                           !
#***************************************************************************!

import nextnanopy as nn                                     # package necessary to read output results from nextnano++
import numpy as np                                          # package with linear algebra (always important)
import kwant as kw                                          # Kwant - you know about it already! (for quantum transport)
from scipy.interpolate import interp2d                      # package with algorithms (here for interpolation only)
import matplotlib as mpl
import matplotlib.pyplot as plt
import os

#---------------------------------------------------------------------------#
# path where the results of nextnano++ are stored                           #
#---------------------------------------------------------------------------#

# EDIT THE PATH TO YOUR OUTPUT FOLDER                                                                           
# EDIT THE PATH TO YOUR OUTPUT FOLDER
# EDIT THE PATH TO YOUR OUTPUT FOLDER       
path_extracted_potential_Poisson = r'C:\...\3D_conductance_in_top_gated_2DEG_exercise_nnp'                                                                                
path_extracted_potential_QM      = r'C:\...\3D_conductance_in_top_gated_2DEG_QM_exercise_nnp'
# EDIT THE PATH TO YOUR OUTPUT FOLDER
# EDIT THE PATH TO YOUR OUTPUT FOLDER    
# EDIT THE PATH TO YOUR OUTPUT FOLDER


current_directory = os.path.dirname(__file__)

# simulations in nextnano++

number_of_bias = 101                                        # number of input files generated by nextnano++ 
Gate_Volt_min = -1.5                                        # voltage on the top gate for the first element of the sweep
Gate_Volt_max = 0.0                                         # voltage on the top gate for the last element of the sweep

#---------------------------------------------------------------------------#
# constants                                                                 #
#---------------------------------------------------------------------------#

e    = 1.602e-19                                            # electron charge (C)
hbar = 6.626e-34/2/np.pi                                    # Dirac constant (Js)
h    = 6.626e-34                                            # Planck constant (Js)
nm   = 1e-9                                                 # 1 nanometer (m)
        
ms = 0.067 * 9.109e-31                                      # an effective mass of electrons in 2DEG 
a = 2                                                       # lattice constant of the tight-binding system (nm)
T = hbar*hbar/2/nm/nm/ms/e                                  # constant to convert from eV (output of nn++) to kwant energy unit

#---------------------------------------------------------------------------#
# parameters                                                                #
#---------------------------------------------------------------------------#

left = -200                                                 # left limit of the scattering region (nm)
right = 200                                                 # right limit of the scattering region (nm)
    
bottom = -200                                               # lower limit of the scattering region (nm)
top = 200                                                   # upper limit of the scattering region (nm)
    
#---------------------------------------------------------------------------#
#plotter settings                                                           #
#---------------------------------------------------------------------------#
  
mpl.rc('figure', figsize=(8, 6))
mpl.rc('axes', labelsize=15, titlesize=20)
mpl.rc('xtick', labelsize=15)
mpl.rc('ytick', labelsize=15)
mpl.rc('axes', prop_cycle=mpl.cycler('color', ['black']))   
    
def qpc_potential(site):                                    # potential in the scattering region
    x, y = site.pos 
        
    return -interpolated_potential(x,y)[0]/T    
    
    
def lead_potential(site):                                   # potential in the left lead
    x, y = site.pos 
        
    return -interpolated_potential(left,y)[0]/T     
    
    
def lead_potential2(site):                                  # potential in the right lead
    x, y = site.pos 
    
    return -interpolated_potential(right,y)[0]/T    
    
    
def make_lead_input(pot, t=1):                              # defining the right lead
    
    def onsite(*args):                                      # return the matrix element of a given site (A_i,j)
        return 4 * t - pot(*args)   
        
    def hopping(*args):                                     # return the hopping between two given sites (T_i,j,i+1,j)
        return -t 

    syst = kw.Builder(kw.TranslationalSymmetry([-a, 0]))    # specify a translational symmetry 


    syst[(lat(left//a, y) for y in np.arange(bottom//a+1,top//a,1))] = onsite # define the matrix element of each site 
    syst[lat.neighbors()] = hopping                         # define the hopping parameters between closest neighbours  
    
    return syst


def make_lead_output(pot, t=1):                             # defining the left lead
   
    def onsite(*args):                                      # return the matrix element of a given site (A_i,j)
        return 4 * t - pot(*args)
    
    def hopping(*args):                                     # return the hopping between two given sites (T_i,j,i+1,j)
        return -t 

    syst = kw.Builder(kw.TranslationalSymmetry([a, 0]))     # specifiy a translational symmetry 
    
    syst[(lat(right//a, y) for y in np.arange(bottom//a+1,top//a,1))] = onsite # define the matrix element of each site
    syst[lat.neighbors()] = hopping                         # define the hopping parameters between closest neighbours
    
    return syst


def make_system(pot1,pot2,pot3, t=1):                       # define the scattering region
    
    def onsite(*args):
        return 4 * t - pot1(*args)
    
    def hopping(*args):
        return -t

    # Construct the scattering region.
    
    # 1st step - creating an “empty” tight binding system
    sr = kw.Builder()
    
    # 2st step - setting matrix elements
    sr[(lat(x, y) for x in np.arange(left//a+1,right//a,1) for y in np.arange(bottom//a+1,top//a,1))] = onsite
    
    # 2st step - setting hoppings
    sr[lat.neighbors()] = hopping

    # 3rd step - Construct the leads and attach them to the scattering region.
    lead = make_lead_input(pot2, t)
    sr.attach_lead(lead)

    lead3 = make_lead_output(pot3, t)
    sr.attach_lead(lead3)

    return sr


# +++++ Reading, Preparing, and Simulating +++++ #
# ++++++++++++++++++++++++++++++++++++++++++++++ #

conductance = [[],[]]
V=np.linspace(Gate_Volt_min, Gate_Volt_max, number_of_bias)

i=0
for path_extracted_potential in [path_extracted_potential_Poisson,path_extracted_potential_QM]:
    if i==0 :
        print('\n----------- Only Poisson -------------')
        data_file = fr'bandedges_2d_2deg_slice.fld'
        output_file = open(os.path.join(current_directory,'conductance_Poisson_exercise.dat'),'w')
        extracted_data = 'Gamma'
    else:
        print('\n\n-----  Schroedinger-Poisson ----------')
        output_file = open(os.path.join(current_directory,'conductance_Poisson-Schroedinger_exercise.dat'),'w')  
        data_file = os.path.join('Quantum','energy_subbands_quantum_region_Gamma_2d_2deg_slice.fld')
        extracted_data = 'E_1'

    output_file.write('bias{V]    conductance[2e^2/h]\n')

    for k in range(number_of_bias):

        # reading 
        
        extracted_potential = nn.DataFile(os.path.join(path_extracted_potential, fr'bias_{str(k).zfill(5)}', data_file) ,product='nextnano++')
        x = extracted_potential.coords['x'].value
        y = extracted_potential.coords['y'].value
        potential = extracted_potential.variables[extracted_data].value
    
        # preparing
        
        interpolated_potential=interp2d(x, y, potential.T)
        lat = kw.lattice.square(a)
        qpc = make_system(qpc_potential, lead_potential, lead_potential2, t=1/a**2)
        
        # plotting electric potential for Vgate = -1.11V
        if k == 26:
            if i==0:
                kw.plot(qpc, show= False, file='QPC - scattering region.png')
                print('\nsaved image \'QPC - scattering region.png\n\'')
            
            potential_plot = kw.plotter.map(qpc, lambda s: qpc_potential(s,), show= False)
            if i==0:
                potential_plot.savefig(os.path.join(current_directory,'Potential for -1.11 V_exercise.png'))
                print('\nsaved image \'Potential for -1.11 V.png\'')    
            else:
                potential_plot.savefig(os.path.join(current_directory,'Potential for -1.11 V_QM_exercise.png'))
                print('\nsaved image \'Potential for -1.11 V.png\'') 
            plt.close(potential_plot)                
                 
        fqpc = qpc.finalized()
        
        # plotting band structure of the lead 0 ( at the left of the device )
        if k == 26:
            bandedges_plot = kw.plotter.bands(fqpc.leads[0], show= False)  
            if i==0 :
                bandedges_plot.savefig(os.path.join(current_directory,'Band structure of the lead 0 for -1.11 V_exercise.png'))
                print('\nsaved image \'Band structure of the lead 0 for -1.11 V.png\'')
            else:
                bandedges_plot.savefig(os.path.join(current_directory,'Band structure of the lead 0 for -1.11 V_QM_exercise.png'))
                print('\nsaved image \'Band structure of the lead 0 for -1.11 V_QM_exercise.png\'')                
            plt.close(bandedges_plot)

        # simulating      
        smatrix = kw.smatrix(fqpc, 0, in_leads = [0])
        conductance[i].append(smatrix.transmission(1,0))
        output_file.write(str(V[k]) + '   ' + str(smatrix.transmission(1,0)) + '\n')
        print("\nIteration %d   bias %5.3f   conductance %5.4f {2 e^2/h}" % (k,V[k],smatrix.transmission(1,0))) 

    output_file.close()
    i = i + 1

    
# +++++ Plotting +++++ #
# ++++++++++++++++++++ #


### make large plots and labels
mpl.rc('figure', figsize=(8, 6))
mpl.rc('axes', labelsize=15, titlesize=20)
mpl.rc('xtick', labelsize=15)
mpl.rc('ytick', labelsize=15)

V=np.linspace(Gate_Volt_min, Gate_Volt_max, number_of_bias)

plt.xlabel('$V_{gate} (V)$')
plt.ylabel('Conductance ($2e^2/h$)')

plt.plot(V, conductance[0], color = 'blue')
plt.title('Conductance between lead 0 to lead 1\n')
plt.savefig(os.path.join(current_directory,'Conductance lead 0 to 1_exercise.png'))
plt.close()

plt.plot(V, conductance[1], color = 'red')
plt.title('Conductance between lead 0 to lead 1\n')
plt.savefig(os.path.join(current_directory,'Conductance lead 0 to 1_QM_exercise.png'))
plt.close()

plt.plot(V, conductance[0], color = 'blue', label='No quantization along the growth direction')
plt.plot(V, conductance[1], color = 'red', label='With quantization along the growth direction')
plt.title('Comparison Conductance between lead 0 to lead 1\n')
plt.legend(loc="upper right")
plt.savefig(os.path.join(current_directory,'Comparison Conductance lead 0 to 1_exercise.png'))

